## Demo for Python with C++ Backend

### Prerequisite

* Python 3.7.*
* Linux

### Run

```sh
$ make
python python/demo.py
```

For runing test program:
```sh
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/abspath/to/CppBackend/lib
./test
```

### Implementation Notes

* C++ Name Mangling

  C++ code compiled with g++ compiler will encounter the name mangling problem after loading the dynamic library at Python end, where you can't get the functions by orginal names which are defined in `.cc` files.

  To avoid this, it's better to provide a `C`-style function (no namespace, class memthod, etc.) inside `extern "C" {}` to tell the compiler (e.g. g++) not to use the name mangling. See the details at `src/c_api_wrapper.cc`
  
**Note1** if the `.so` library is generated by linking other `.so` library dependencies, make sure in `Makefile`, the path of other `.so` should be in absolute path (otherwise cdll.LoadLibrary may not be able find the correct `.so` dependency locations when loading library from python). For example, in `Makefile` one could specify `-L/abspath/to/libxxx -Wl,-rpath=/absolute/path/`.
  
**Note2** `cdll` loaded dynamic library assumes the return type and input types of each function is `int`. User should specify which type to be returned through `libs.xxxfunc.restype = ctypes.c_xxtype`. Same as input types through `libs.xxxfunc.argtypes = list[ctypes.xxtypes]`. Note if this is not specified, pointer may be wrong in 64bit systems since the pointer address could be larger than maximum int value.
  
**Note3** Don't use smart pointers (e.g., std::shared_ptr<T>) as input types or return type. This will get stuck when python calls the function.

* Python ctypes

  Details are [here](https://docs.python.org/3.7/library/ctypes.html#module-ctypes)
